//Array das imagens

PGraphics[] triangulo = new PGraphics[8];

//Posição cartesiana

float[][] x1 = new float[8][125];
float[][] y1 = new float[8][125];
float[][] x2 = new float[8][125];
float[][] y2 = new float[8][125];
float[][] x3 = new float[8][125];
float[][] y3 = new float[8][125];

//Variáveis do fill

float[][] huef = new float[8][125];
float[][] satf = new float[8][125];
float[][] brightf = new float[8][125];
float[][] opacityf = new float[8][125];



//float[][] x1, float[][] y1, float[][] x2, float[][] y2, float[][] x3, float[][] y3, float[][] huef, float[][] satf, float[][] brightf, float[][] opacityf 
//float[][] x1, float[][] y1, float[][] x2, float[][] y2, float[][] x3, float[][] y3, float[][] huef, float[][] satf, float[][] brightf, float[][] opacityf 

//Variáveis de contagem

int i = 0;
int j = 0;


// tira a media de uma lista
float med (float[] lista){
  int k, a; 
  float somat = 0, med;
  k = lista.length;
  for (a = 0; a < k; a = a + 1){
    somat = somat + lista[a]; 
  }
  med = somat/k;
  
  return med;
}


// essa funcao faz uma lista de medias com base em uma lista de uma lista de listas
float[] medl (float[][] lista){
  int b; 
  float[] medl = new float[lista.length];
  
  for (b = 0; b < lista.length; b = b + 1)
    medl[b] = med (lista [b]); 
  
  return medl;
}


// essa funcao da a lista do quadrado da porcentagem do desvio com base no maior valor.
float[] quadrado (float[] l){
  float []dif = new float [l.length];
  float [] prov = new float [l.length];
  int a;
  for (a = 0; a < l.length; a = a + 1)
    if (l[a] < med(l))
      dif[a] = (med(l) - l[a]);
    else
      dif[a] = (l[a] - med(l));
  arrayCopy(dif, prov); 
  sort(prov); 
  
  for (a = 0; a < l.length - 1; a = a + 1)
    dif[a] = dif[a]/prov[prov.length - 1];
    dif[a] = sq(dif[a]);
    
  return dif;
}


//essa funcao calcula a "distancia"/diferenca de cada imagem e formatar o resultado em uma lista
double []distancia (float[][] x1, float[][] y1, float[][] x2, float[][] y2, float[][] x3, float[][] y3, float[][] huef, float[][] satf, float[][] brightf, float[][] opacityf ){
  //float xl, yl, Widthl, Heightl, huel, satl, brigthl, opacityl, b; 
  int a;
  double []distancia = new double [x1.length];
  for (a = 0; a < x1.length; a = a + 1)
    distancia[a] = sqrt(quadrado (medl(x1))[a] + quadrado (medl(y1))[a] +quadrado (medl(x2))[a] + quadrado (medl(y2))[a] + quadrado (medl(x3))[a] +
    quadrado (medl(y3))[a] + quadrado (medl(huef))[a] + quadrado (medl(satf))[a] + quadrado (medl(brightf))[a] + quadrado (medl(opacityf))[a]);
    
  return distancia;
}





void setup() {
  int k;
  size(720,720);
  background(0);
  
  while(i < 8){
    j = 0;
    while(j < 125){
    
      //Geração de variáveis aleatórias
    
      x1[i][j] = random(900) - 90;
      y1[i][j] = random(900) - 90;
      x2[i][j] = random(900) - 90;
      y2[i][j] = random(900) - 90;
      x3[i][j] = random(900) - 90;
      y3[i][j] = random(900) - 90;
      huef[i][j] = random(360);
      satf[i][j] = random(100);
      if (satf[i][j] > 15 && satf[i][j] < 40) satf[i][j] = satf[i][j] + 50;
      brightf[i][j] = random(100);
      opacityf[i][j] = random(100);
      if (opacityf[i][j] < 25) opacityf[i][j] = 0;
    
      j = j + 1;
    }
    i = i + 1;
  }

  for (k = 0; k < x1.length ; k = k + 1 )
    println (distancia (x1, y1, x2, y2, x3, y3, huef, satf, brightf, opacityf)[k]);

  
  
}
